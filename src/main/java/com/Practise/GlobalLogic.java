package com.Practise;

public class GlobalLogic {
//find max of subarray
    //suppose string class is removed how to create + handle string pooling


//    parent class {
//       String run()
//    }
//    chile class extends parent
//    Integer run ()
//        is it possible  to have different return type




//    class call{
//        de.have (null) which one will be called
//    }
// class de{
//
//     have(Object value){
//
//     }
//
//     have(String value){
//
//     }
//
//     have(Integer value){
//
//     }
//
//
// }
//
//}
//

    //why to use static benefit.

///// second round

    //when to use generic

    // when to use stream


    /*
    Integer[] intArray = { 1, 2, 3 };
        String[] stringArray = {"Hello", "World"};
printArray
printArray(intArray);


//make generic parametedr acceptance

   printArray(Object[] input){
		for(Object o:imput){

			if(o.instanceOf(String) ){
			   SOP((String)o)

			}else
			{
			SOP(Integer)o

			}

		List<?> list =getArray
		}

		new

		//find how many time instance was created in 900 line of code

		Person p = new person(w)

		Person p1 = new person()

		Person p2 = new person()

	map.put( , )

	Map<>  -> put(instance P, map.get(instance)+1 )

	}
	Map<Integer,IN> put()

	if i have method that take input 9 retrun 3
	if 3 then return 9



	//get duplicate in java 8 using stream

	inpList.stream().forEach( i-> {
	int
	Map<Integer,IN> put(i, map.get(instance)+1  )
	if()

	}).filter().map().to



	//duplicate email
	select e.name , e.mobile number Employee e where count(e.mobile)>1 And e.name =


	select e.name , e.mobile number Employee e where e.email containe svalid email
SELECT * FROM people WHERE email NOT LIKE '%_@__%.__%'



	factory design pattern drawback

	design pattern in microservice

	@RestController @ Controller
	@Controller is used to mark classes as Spring MVC Controller.
	@RestController is a convenience annotation that does nothing more than adding the @Controller and @ResponseBody annotations (see: Javadoc)
	So the following two controller definitions should do the same

	@Controller
	@ResponseBody
	public class MyController { }

	@RestController
	public class MyRestController { }

    with eg
    Map vs ConcurrentHashMap


    Patch vs put
     */


}
