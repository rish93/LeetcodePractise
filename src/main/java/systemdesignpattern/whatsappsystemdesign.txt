->  Components
1) Functional Requirements
    > Send/receive chat msg
    > group chat 2-256 users
    > Track msg status
    > use phone no.
    > push notification
    > receive msg when online
    > Analytics/Monitoring
    > End to end encryption
    > Media files support
    > Whatsapp web support

2) Non functional
    > Highly available
    > scalable
    > minimal latency
    > consistency
    > durability

3) Api Specs
  * registeration
    > Register account (API key + user i/p in body)
    > validate account (API key, userId, validation code (sms))
  * chat direct
    > initiate direct chat session (API key, userId1(sender), userId2(receiver), handShakeInfo)
    > send  msg (API key,, sessionId, msgType{statusmsg/directmsg}, msg)
    > get Msg status (API key, msgId)
    >  readNew Msg (apiKey, sessionId, msgId(latest msg id for read pointer of previous msgs ))
    >
  * group chat
    > InitiateGroupChatSession (api key, groupId)
    > addUserToGroup (API key, userId, groupId)
    > removeUserGroup(api key, userId, groupId)
    > promoteUserToAdmin(API key,groupId, userId)


ReferImage. ->  whatsappdesign1
                           <-----> Groups      -----> Database & Coding layer

User > {Routing service}   <-----> Session     -----> Database & Coding layer

                            <-----> Fanout    -----> Push Notification/Database & Coding layer
                            <-----> User       -----> Database & Coding layer
                            <-----> User Registration    -----> SMS Gateway/Database & Coding layer



* Routing service act as gateway between user and other inner services
    > Routes event and msgs from user vice/versa
    > When user comes online app create web socket connection with routing service
    > web socket connection is used to make API calls, and use inner services

* User Registration
    >refer image userregistrationservice.png

    > user table  |userID| name| user code| creationTime
     *entries in user table are time bound ui.e code will expire in time frame

                     -> App server1   \
    *Load balancer    -> App server2     -- Distributed Cache -- distributed datastore
                    -> App server3   /
                                |___________________SMS Gateway


* Group service
    Refer image groupservicewhatsappDB.png
                    -> App server1   \
    *Load balancer    -> App server2     -- Distributed Cache -- distributed datastore
                    -> App server3   /
                             table1 : Group |{pk} groupID| Name| creationTime|members Count|
                             table2 : Group Membership  |{pk}groupID|{pk} UserId| creationTime| TYpe {admin/normal}
Table 2 > benefits when user create account in new device
        the group id is known from table 2

//sharding:
***Sharding in tables (for table2)***
    > Shard the index by group id . benefit {user membership information
         will spread across all the different partitions and group that user belongs }
    ////GroupId is Local Index

    > shard the index by userId .benefit { all the user membership info will
                present in one partition }
    ////UserId is Global Index  {see twitter service from Think Software}



* Session service

    type: /chatSessionService/privateSession/ Group chat session

    1) Dedicated/Private chat session
    2) Group chat session

>  refer image sessionmessage.png
Session |SessionID| CREATIONTIME| TYPE| counter|
        sessionId for user can be generated by combining sender/receivers user id
        sessionId for group can be generated by random id with some prefix unique
            (diff from other group id)


SessionMessage  |SessionID {PK}| Timestamp {pk}| createTime| type | senderId |
                    | RecipientId | Data |
    > Session msg table has record for every new msg in grpup distinguished by timestamp
    {epoch time with incremented counter }
    > eg. for every new msg get counter from table1 increment it
        then use it with epoch in table2 and the commit transaction for both
        tables

    > Table1 & table2 are sharded by session ID
    > means all the msgs of that session will belong to single partition
    >  if we shard based on sender id eg if we want ot read msg for group chat session
        > you have to read all the partition of msg for all users that belong in that group



* Fanout service
        > Fanout service tries to send msgg to routing service
        > if user is offline/404 the it return unavailable
        > fanout service triggers push notification

     for complete flow   refer image newmessageingroupsession.PNG


*Push notification service
                PNS (servers) eg APple push notification server
                                /GoogleCloudMssaging
                                /Firebase Cloud msgning
                                /windows Notification Servers
                        /                       \
                       /                         \
IOS/Android device   -->                         <-----      Push notification service

    > deaoemon process run in device provided by device OS
    > it create connection with PNS (socket connection)
    > Each app register to OS processes
    > Applications PNService also has connection PNS dedicated of OS
    > In fanout case PNS service checks token is registered with PNS  of OS Process
    > IF token is registered it call PNS of OS for new msg












































